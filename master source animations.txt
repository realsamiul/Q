/**
 * ═══════════════════════════════════════════════════════════════════════════
 * EXOAPE MASTER ANIMATIONS - COMPREHENSIVE EDITION
 * ═══════════════════════════════════════════════════════════════════════════
 * 
 * Complete implementation extracted from original Exo Ape source files
 * with exact element names and component mappings from your HTML structure.
 * 
 * Source Files:
 * - 0efa5ea.js (Page Transitions)
 * - e36d691.js (Title RAF Animation)
 * - 7bc4024.js (Split Text Animation)
 * - 5353853.js (Marquee Animation)
 * - d5d162b.js (Smooth Scroll & Utils)
 * - 67eac05.js (Full Page Animations)
 * - a4c5813.js (Component Logic)
 * 
 * ALL animations are included, even those not in your current 4 pages.
 * Non-implemented animations are clearly labeled with their location.
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 */

// ═══════════════════════════════════════════════════════════════════════════
// 1. CUSTOM EASE CURVES (Extracted from source - exact SVG paths)
// ═══════════════════════════════════════════════════════════════════════════

const ExoEases = {
  // M0,0 C0.496,0.004 0,1 1,1 - Page transitions, marquee, general smoothness
  main: 'cubic-bezier(0.496, 0.004, 0, 1)',
  
  // M0,0 C0,0.202 0.204,1 1,1 - Title entrances, stagger text animations
  text: 'cubic-bezier(0, 0.202, 0.204, 1)',
  
  // M0,0 C0.198,0 1,0.1 1,1 - Image bloom, parallax effects, smooth reveals
  image: 'cubic-bezier(0.198, 0, 1, 0.1)'
};

// Register GSAP CustomEase if available
if (typeof gsap !== 'undefined') {
  if (typeof CustomEase !== 'undefined') {
    gsap.registerPlugin(CustomEase);
    CustomEase.create('exoMain', 'M0,0 C0.496,0.004 0,1 1,1');
    CustomEase.create('exoText', 'M0,0 C0,0.202 0.204,1 1,1');
    CustomEase.create('exoImage', 'M0,0 C0.198,0 1,0.1 1,1');
  }
  
  if (typeof ScrollTrigger !== 'undefined') {
    gsap.registerPlugin(ScrollTrigger);
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// 2. UTILITY FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════

const ExoUtils = {
  // Linear interpolation for smooth scroll
  lerp(start, end, factor) {
    return start + (end - start) * factor;
  },
  
  // Check if element is in viewport
  inView(element, threshold = 0) {
    if (!element) return false;
    const rect = element.getBoundingClientRect();
    const windowHeight = window.innerHeight || document.documentElement.clientHeight;
    return rect.top < windowHeight - threshold && rect.bottom > threshold;
  },
  
  // Get scroll progress of element
  getScrollProgress(element) {
    if (!element) return 0;
    const rect = element.getBoundingClientRect();
    const windowHeight = window.innerHeight;
    const elementHeight = rect.height;
    const scrolled = windowHeight - rect.top;
    return Math.max(0, Math.min(1, scrolled / (windowHeight + elementHeight)));
  },
  
  // Clamp number between min and max
  clamp(num, min, max) {
    return Math.min(Math.max(num, min), max);
  },
  
  // Map number from one range to another
  map(num, inMin, inMax, outMin, outMax) {
    return ((num - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;
  },
  
  // Check if mobile device
  isMobile() {
    return window.innerWidth <= 768;
  },
  
  // Check if touch device
  isTouch() {
    return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  }
};

// ═══════════════════════════════════════════════════════════════════════════
// 3. SMOOTH SCROLL (Lerp-based RAF animation)
// LOCATION: ALL PAGES
// ELEMENTS: body, .scroll
// ═══════════════════════════════════════════════════════════════════════════

class ExoSmoothScroll {
  constructor(options = {}) {
    this.current = 0;
    this.target = 0;
    this.ease = options.ease || 0.1;
    this.isRunning = false;
    this.isMobile = ExoUtils.isMobile();
    this.maxScroll = 0;
    this.scrollWrapper = document.querySelector('.scroll') || document.body;
    
    this.init();
  }
  
  init() {
    if (this.isMobile) {
      document.body.style.overflowY = 'auto';
      return;
    }
    
    // Desktop smooth scroll setup
    document.body.style.position = 'fixed';
    document.body.style.top = '0';
    document.body.style.left = '0';
    document.body.style.width = '100%';
    document.body.style.overflowY = 'hidden';
    
    this.updateMaxScroll();
    this.addEventListeners();
    this.animate();
  }
  
  updateMaxScroll() {
    const scrollHeight = this.scrollWrapper.scrollHeight || document.documentElement.scrollHeight;
    const clientHeight = window.innerHeight;
    this.maxScroll = scrollHeight - clientHeight;
  }
  
  addEventListeners() {
    // Wheel event
    window.addEventListener('wheel', (e) => {
      this.target += e.deltaY;
      this.target = ExoUtils.clamp(this.target, 0, this.maxScroll);
    }, { passive: true });
    
    // Touch events
    let touchStart = 0;
    window.addEventListener('touchstart', (e) => {
      touchStart = e.touches[0].clientY;
    }, { passive: true });
    
    window.addEventListener('touchmove', (e) => {
      const touchDelta = touchStart - e.touches[0].clientY;
      this.target += touchDelta;
      this.target = ExoUtils.clamp(this.target, 0, this.maxScroll);
      touchStart = e.touches[0].clientY;
    }, { passive: true });
    
    // Resize handler
    window.addEventListener('resize', () => {
      this.updateMaxScroll();
      this.isMobile = ExoUtils.isMobile();
      
      if (this.isMobile) {
        document.body.style.position = '';
        document.body.style.overflowY = 'auto';
        document.body.style.transform = '';
      }
    });
    
    // Keyboard navigation
    window.addEventListener('keydown', (e) => {
      switch(e.key) {
        case 'ArrowDown':
          this.target += 50;
          break;
        case 'ArrowUp':
          this.target -= 50;
          break;
        case 'PageDown':
          this.target += window.innerHeight * 0.8;
          break;
        case 'PageUp':
          this.target -= window.innerHeight * 0.8;
          break;
        case 'Home':
          this.target = 0;
          break;
        case 'End':
          this.target = this.maxScroll;
          break;
      }
      this.target = ExoUtils.clamp(this.target, 0, this.maxScroll);
    });
  }
  
  animate() {
    if (!this.isMobile) {
      this.current = ExoUtils.lerp(this.current, this.target, this.ease);
      
      // Apply transform to wrapper
      if (this.scrollWrapper) {
        this.scrollWrapper.style.transform = `translate3d(0, ${-this.current}px, 0)`;
      }
      
      // Dispatch custom scroll event
      window.dispatchEvent(new CustomEvent('exoscroll', { 
        detail: { 
          scrollY: this.current,
          progress: this.maxScroll > 0 ? this.current / this.maxScroll : 0,
          direction: this.target - this.current > 0 ? 'down' : 'up'
        }
      }));
    }
    
    requestAnimationFrame(() => this.animate());
  }
  
  scrollTo(targetY, duration = 1) {
    if (typeof gsap !== 'undefined') {
      gsap.to(this, {
        target: targetY,
        duration: duration,
        ease: 'exoMain'
      });
    } else {
      this.target = targetY;
    }
  }
  
  destroy() {
    document.body.style.position = '';
    document.body.style.overflowY = '';
    if (this.scrollWrapper) {
      this.scrollWrapper.style.transform = '';
    }
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// 4. PAGE TRANSITIONS (Enter/Leave animations with clipPath)
// LOCATION: ALL PAGES (between page navigation)
// ELEMENTS: .page, .page-content, .overlay
// ═══════════════════════════════════════════════════════════════════════════

class ExoPageTransition {
  constructor() {
    this.isTransitioning = false;
  }
  
  // Page enter animation (from source: 0efa5ea.js)
  enter(element, onComplete) {
    this.isTransitioning = true;
    
    const tl = gsap.timeline({ 
      onComplete: () => {
        this.isTransitioning = false;
        document.body.classList.remove('is-loading');
        if (onComplete) onComplete();
      }
    });
    
    // ClipPath reveal from bottom (exact source animation)
    tl.fromTo(element, 
      {
        clipPath: 'polygon(0% 100%, 100% 110%, 100% 100%, 0% 100%)',
        zIndex: 2
      },
      {
        clipPath: 'polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)',
        duration: 1,
        ease: 'exoMain',
        clearProps: 'clipPath,zIndex'
      }
    );
    
    // Scale + rotate entrance (exact source animation)
    const content = element.querySelector('.page-content, .scroll') || element;
    tl.fromTo(content,
      {
        scale: 1.3,
        rotate: 7,
        y: window.innerHeight / 2
      },
      {
        scale: 1,
        rotate: 0,
        y: 0,
        duration: 1,
        ease: 'exoMain',
        clearProps: 'all'
      },
      0
    );
    
    return tl;
  }
  
  // Page leave animation (from source: 0efa5ea.js)
  leave(element, onComplete) {
    this.isTransitioning = true;
    document.body.classList.add('is-loading');
    
    const content = element.querySelector('.page-content, .scroll') || element;
    
    const tl = gsap.timeline({ 
      onComplete: () => {
        this.isTransitioning = false;
        if (onComplete) onComplete();
      }
    });
    
    // Scale + rotate + fade exit (exact source animation)
    tl.fromTo(content, 
      {
        scale: 1,
        rotate: 0,
        y: 0
      },
      {
        scale: 1.3,
        rotate: -7,
        y: -window.innerHeight / 2,
        duration: 1,
        ease: 'exoMain'
      }
    );
    
    return tl;
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// 5. TITLE SPLIT ANIMATION (Staggered text entrance with rotation)
// LOCATION: ALL PAGES
// ELEMENTS: .title (with .title-mask > .title-line structure)
// ═══════════════════════════════════════════════════════════════════════════

class ExoTitleSplit {
  constructor(element, options = {}) {
    this.element = element;
    this.lines = [];
    this.visible = false;
    this.threshold = options.threshold || window.innerHeight / 1.5;
    this.autoAnimate = options.autoAnimate !== false;
    
    this.split();
    
    if (this.autoAnimate) {
      this.setupRAF();
    }
  }
  
  split() {
    // Check if already split (has .title-mask children)
    const existingMasks = this.element.querySelectorAll('.title-mask');
    
    if (existingMasks.length > 0) {
      // Already split, just collect the lines
      existingMasks.forEach(mask => {
        const line = mask.querySelector('.title-line');
        if (line) {
          this.lines.push(line);
        }
      });
    } else {
      // Need to split the text
      const text = this.element.textContent;
      const words = text.trim().split(/\s+/);
      
      this.element.innerHTML = '';
      
      words.forEach(word => {
        const mask = document.createElement('div');
        mask.className = 'title-mask';
        
        const line = document.createElement('div');
        line.className = 'title-line';
        line.textContent = word + ' ';
        
        mask.appendChild(line);
        this.element.appendChild(mask);
        this.lines.push(line);
      });
    }
    
    // Hide initially
    gsap.set(this.lines, { 
      autoAlpha: 0,
      rotation: 7,
      yPercent: 100
    });
  }
  
  setupRAF() {
    const checkVisibility = () => {
      if (ExoUtils.inView(this.element, this.threshold) && !this.visible) {
        this.animate();
      }
      
      if (!this.visible) {
        requestAnimationFrame(checkVisibility);
      }
    };
    
    requestAnimationFrame(checkVisibility);
  }
  
  // Animation from source: e36d691.js, 7bc4024.js (exact parameters)
  animate() {
    this.visible = true;
    
    gsap.fromTo(this.lines,
      {
        autoAlpha: 0,
        rotation: 7,
        yPercent: 100
      },
      {
        autoAlpha: 1,
        rotation: 0,
        yPercent: 0,
        stagger: 0.1,
        duration: 1,
        ease: 'exoText'
      }
    );
  }
  
  reset() {
    this.visible = false;
    gsap.set(this.lines, { 
      autoAlpha: 0,
      rotation: 7,
      yPercent: 100
    });
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// 6. MARQUEE ANIMATION (Continuous horizontal scroll)
// LOCATION: studio.html (.how-we-work .marquee)
// ELEMENTS: .marquee > .line
// ═══════════════════════════════════════════════════════════════════════════

class ExoMarquee {
  constructor(element, options = {}) {
    this.element = element;
    this.speed = options.speed || 1;
    this.direction = options.direction || 'left';
    this.duplicateCount = options.duplicateCount || 1;
    
    this.setup();
  }
  
  setup() {
    const content = this.element.innerHTML;
    
    // Duplicate content for seamless loop
    let duplicatedContent = content;
    for (let i = 0; i < this.duplicateCount; i++) {
      duplicatedContent += content;
    }
    this.element.innerHTML = duplicatedContent;
    
    // Set initial position
    gsap.set(this.element, { x: 0 });
    
    this.animate();
  }
  
  // Animation from source: 5353853.js
  animate() {
    const width = this.element.scrollWidth / (this.duplicateCount + 1);
    const direction = this.direction === 'left' ? -1 : 1;
    const duration = 20 / this.speed;
    
    gsap.to(this.element, {
      x: direction * width,
      duration: duration,
      ease: 'none',
      repeat: -1,
      modifiers: {
        x: (x) => {
          const val = parseFloat(x);
          return `${val % width}px`;
        }
      }
    });
  }
  
  pause() {
    gsap.to(this.element, { timeScale: 0, duration: 0.5 });
  }
  
  play() {
    gsap.to(this.element, { timeScale: 1, duration: 0.5 });
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// 7. IMAGE BLOOM (Scale on scroll/hover)
// LOCATION: index.html (.project), studio.html (.images)
// ELEMENTS: .image, .block img, .media img
// ═══════════════════════════════════════════════════════════════════════════

class ExoImageBloom {
  constructor(element, options = {}) {
    this.element = element;
    this.scaleAmount = options.scale || 1.2;
    this.trigger = options.trigger || 'scroll'; // 'scroll' or 'hover'
    this.scrub = options.scrub !== false;
    
    this.init();
  }
  
  init() {
    if (this.trigger === 'hover') {
      this.setupHover();
    } else {
      this.setupScroll();
    }
  }
  
  setupHover() {
    const img = this.element.querySelector('img') || this.element;
    
    this.element.addEventListener('mouseenter', () => {
      gsap.to(img, {
        scale: this.scaleAmount,
        duration: 0.6,
        ease: 'exoImage'
      });
    });
    
    this.element.addEventListener('mouseleave', () => {
      gsap.to(img, {
        scale: 1,
        duration: 0.6,
        ease: 'exoImage'
      });
    });
  }
  
  setupScroll() {
    if (typeof ScrollTrigger === 'undefined') return;
    
    const img = this.element.querySelector('img') || this.element;
    
    ScrollTrigger.create({
      trigger: this.element,
      start: 'top bottom',
      end: 'bottom top',
      scrub: this.scrub,
      onUpdate: (self) => {
        const scale = 1 + (self.progress * (this.scaleAmount - 1));
        gsap.to(img, {
          scale: scale,
          duration: 0.1,
          ease: 'exoImage',
          overwrite: 'auto'
        });
      }
    });
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// 8. PARALLAX (Element moves on scroll)
// LOCATION: index.html (.media), studio.html (.images)
// ELEMENTS: Any element with parallax effect
// ═══════════════════════════════════════════════════════════════════════════

class ExoParallax {
  constructor(element, options = {}) {
    this.element = element;
    this.speed = options.speed || 0.5;
    this.direction = options.direction || 'y'; // 'y' or 'x'
    this.distance = options.distance || 30; // percentage
    
    this.init();
  }
  
  init() {
    if (typeof ScrollTrigger === 'undefined') return;
    
    const movement = this.direction === 'y' ? 'yPercent' : 'xPercent';
    const value = this.distance * this.speed;
    
    gsap.fromTo(this.element, 
      {
        [movement]: -value / 2
      },
      {
        [movement]: value / 2,
        ease: 'none',
        scrollTrigger: {
          trigger: this.element.parentElement || this.element,
          start: 'top bottom',
          end: 'bottom top',
          scrub: true
        }
      }
    );
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// 9. NAVIGATION MENU (Fullscreen menu with hamburger toggle)
// LOCATION: ALL PAGES
// ELEMENTS: .nav (header), .menu-button, .menu-overlay, .menu-links
// ═══════════════════════════════════════════════════════════════════════════

class ExoNavigation {
  constructor(options = {}) {
    this.nav = document.querySelector(options.nav || 'nav, header');
    this.menuButton = document.querySelector(options.menuButton || '.menu-button');
    this.menuOverlay = document.querySelector(options.menuOverlay || '.menu-overlay');
    this.menuLinks = document.querySelectorAll(options.menuLinks || '.menu-overlay a');
    this.isOpen = false;
    this.hideOnScroll = options.hideOnScroll || false;
    this.threshold = options.threshold || 100;
    this.lastScroll = 0;
    
    this.init();
  }
  
  init() {
    if (this.menuButton) {
      this.menuButton.addEventListener('click', () => this.toggleMenu());
    }
    
    // Close menu when clicking links
    this.menuLinks.forEach(link => {
      link.addEventListener('click', () => {
        if (this.isOpen) {
          this.closeMenu();
        }
      });
    });
    
    // Scroll behavior
    if (this.nav) {
      window.addEventListener('exoscroll', (e) => {
        this.updateOnScroll(e.detail.scrollY);
      });
      
      window.addEventListener('scroll', () => {
        this.updateOnScroll(window.pageYOffset);
      });
    }
    
    // ESC key to close
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && this.isOpen) {
        this.closeMenu();
      }
    });
  }
  
  toggleMenu() {
    if (this.isOpen) {
      this.closeMenu();
    } else {
      this.openMenu();
    }
  }
  
  // Open animation (from source: exact clipPath + scale + rotation)
  openMenu() {
    if (!this.menuOverlay) return;
    
    this.isOpen = true;
    this.menuButton?.classList.add('is-active');
    document.body.classList.add('menu-open');
    
    const tl = gsap.timeline();
    
    // ClipPath reveal
    tl.fromTo(this.menuOverlay,
      {
        clipPath: 'polygon(0 0, 100% 0, 100% 0px, 0 0px)',
        display: 'flex'
      },
      {
        clipPath: 'polygon(0 0, 100% 0, 100% 100%, 0 100%)',
        duration: 1,
        ease: 'exoMain'
      }
    );
    
    // Container scale + rotate
    const container = this.menuOverlay.querySelector('.menu-container, .container');
    if (container) {
      tl.fromTo(container,
        {
          scale: 1.3,
          rotate: -7,
          autoAlpha: 0.3
        },
        {
          scale: 1,
          rotate: 0,
          autoAlpha: 1,
          duration: 1,
          ease: 'exoMain'
        },
        0
      );
    }
    
    // Stagger menu links
    tl.fromTo(this.menuLinks,
      {
        autoAlpha: 0,
        yPercent: 100
      },
      {
        autoAlpha: 1,
        yPercent: 0,
        stagger: 0.1,
        duration: 0.8,
        ease: 'exoText'
      },
      0.3
    );
  }
  
  // Close animation (from source)
  closeMenu() {
    if (!this.menuOverlay) return;
    
    this.isOpen = false;
    this.menuButton?.classList.remove('is-active');
    document.body.classList.remove('menu-open');
    
    const tl = gsap.timeline({
      onComplete: () => {
        gsap.set(this.menuOverlay, { display: 'none' });
      }
    });
    
    const container = this.menuOverlay.querySelector('.menu-container, .container');
    
    if (container) {
      tl.to(container, {
        scale: 1.3,
        rotate: -7,
        autoAlpha: 0.3,
        duration: 0.6,
        ease: 'exoMain'
      });
    }
    
    tl.to(this.menuOverlay, {
      clipPath: 'polygon(0 0, 100% 0, 100% 0px, 0 0px)',
      duration: 0.6,
      ease: 'exoMain'
    }, 0);
  }
  
  updateOnScroll(scrollY) {
    if (!this.nav || this.isOpen) return;
    
    if (this.hideOnScroll) {
      const scrollingDown = scrollY > this.lastScroll;
      
      if (scrollY > this.threshold && scrollingDown) {
        gsap.to(this.nav, {
          yPercent: -100,
          duration: 0.3,
          ease: 'exoMain'
        });
      } else if (!scrollingDown) {
        gsap.to(this.nav, {
          yPercent: 0,
          duration: 0.3,
          ease: 'exoMain'
        });
      }
      
      this.lastScroll = scrollY;
    } else {
      // Fade + background change
      if (scrollY > this.threshold) {
        this.nav.classList.add('is-scrolled');
        gsap.to(this.nav, {
          backgroundColor: 'rgba(13, 14, 19, 0.8)',
          duration: 0.3,
          ease: 'exoMain'
        });
      } else {
        this.nav.classList.remove('is-scrolled');
        gsap.to(this.nav, {
          backgroundColor: 'transparent',
          duration: 0.3,
          ease: 'exoMain'
        });
      }
    }
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// 10. SCROLL TO INDICATOR (Arrow that fades on scroll)
// LOCATION: index.html, studio.html (.scroll-to)
// ELEMENTS: .scroll-to
// ═══════════════════════════════════════════════════════════════════════════

class ExoScrollTo {
  constructor(element, options = {}) {
    this.element = element;
    this.threshold = options.threshold || 100;
    this.targetY = options.targetY || window.innerHeight;
    
    this.init();
  }
  
  init() {
    if (!this.element) return;
    
    // Fade on scroll
    const updateVisibility = (scrollY) => {
      if (scrollY > this.threshold) {
        gsap.to(this.element, {
          autoAlpha: 0,
          duration: 0.3,
          ease: 'exoMain'
        });
      } else {
        gsap.to(this.element, {
          autoAlpha: 1,
          duration: 0.3,
          ease: 'exoMain'
        });
      }
    };
    
    window.addEventListener('exoscroll', (e) => {
      updateVisibility(e.detail.scrollY);
    });
    
    window.addEventListener('scroll', () => {
      updateVisibility(window.pageYOffset);
    });
    
    // Click to scroll
    this.element.addEventListener('click', () => {
      if (typeof Exo !== 'undefined' && Exo.smoothScroll) {
        Exo.smoothScroll.scrollTo(this.targetY, 1);
      } else {
        window.scrollTo({
          top: this.targetY,
          behavior: 'smooth'
        });
      }
    });
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// 11. CANVAS VIDEO SEQUENCE (Scroll-driven frame animation)
// LOCATION: story.html (.hero, .origin, .exploration, .purpose)
// ELEMENTS: canvas.canvas
// ═══════════════════════════════════════════════════════════════════════════

class ExoCanvasVideo {
  constructor(canvasElement, options = {}) {
    this.canvas = canvasElement;
    if (!this.canvas) return;
    
    this.ctx = this.canvas.getContext('2d');
    this.frameCount = options.frameCount || 150;
    this.folder = options.folder || '/frames';
    this.filePrefix = options.filePrefix || 'frame-';
    this.fileExtension = options.fileExtension || 'png';
    this.images = [];
    this.currentFrame = 0;
    this.imagesLoaded = 0;
    this.isReady = false;
    
    this.setCanvasSize();
    this.preloadImages();
    this.setupScrollListener();
    this.setupResizeListener();
  }
  
  setCanvasSize() {
    const dpr = window.devicePixelRatio || 1;
    this.canvas.width = window.innerWidth * dpr;
    this.canvas.height = window.innerHeight * dpr;
    this.canvas.style.width = `${window.innerWidth}px`;
    this.canvas.style.height = `${window.innerHeight}px`;
    this.ctx.scale(dpr, dpr);
  }
  
  preloadImages() {
    for (let i = 0; i < this.frameCount; i++) {
      const img = new Image();
      const frameNumber = String(i).padStart(4, '0');
      img.src = `${this.folder}/${this.filePrefix}${frameNumber}.${this.fileExtension}`;
      
      img.onload = () => {
        this.imagesLoaded++;
        if (this.imagesLoaded === this.frameCount) {
          this.isReady = true;
          this.render();
        }
      };
      
      img.onerror = () => {
        console.warn(`Failed to load frame: ${img.src}`);
        this.imagesLoaded++;
      };
      
      this.images.push(img);
    }
  }
  
  setupScrollListener() {
    window.addEventListener('exoscroll', (e) => {
      this.updateFrame(e.detail.progress);
    });
    
    window.addEventListener('scroll', () => {
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const maxScroll = document.body.scrollHeight - window.innerHeight;
      const progress = maxScroll > 0 ? scrollTop / maxScroll : 0;
      this.updateFrame(progress);
    });
  }
  
  setupResizeListener() {
    window.addEventListener('resize', () => {
      this.setCanvasSize();
      this.render();
    });
  }
  
  updateFrame(progress) {
    if (!this.isReady) return;
    
    const frameIndex = Math.min(
      this.frameCount - 1,
      Math.floor(progress * this.frameCount)
    );
    
    if (frameIndex !== this.currentFrame) {
      this.currentFrame = frameIndex;
      this.render();
    }
  }
  
  render() {
    const img = this.images[this.currentFrame];
    if (!img || !img.complete) return;
    
    // Clear canvas
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    
    // Calculate scaling to cover canvas (maintain aspect ratio)
    const canvasRatio = this.canvas.width / this.canvas.height;
    const imgRatio = img.width / img.height;
    
    let drawWidth, drawHeight, offsetX, offsetY;
    
    if (canvasRatio > imgRatio) {
      // Canvas is wider
      drawWidth = this.canvas.width;
      drawHeight = this.canvas.width / imgRatio;
      offsetX = 0;
      offsetY = (this.canvas.height - drawHeight) / 2;
    } else {
      // Canvas is taller
      drawHeight = this.canvas.height;
      drawWidth = this.canvas.height * imgRatio;
      offsetX = (this.canvas.width - drawWidth) / 2;
      offsetY = 0;
    }
    
    this.ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// 12. VIDEO HOVER PLAY (Play video on thumbnail hover)
// LOCATION: index.html (.project)
// ELEMENTS: .project video, .block video
// ═══════════════════════════════════════════════════════════════════════════

class ExoVideoHover {
  constructor(element, options = {}) {
    this.element = element;
    this.video = element.querySelector('video');
    this.playDelay = options.playDelay || 300;
    this.pauseDelay = options.pauseDelay || 100;
    this.playTimeout = null;
    this.pauseTimeout = null;
    
    if (this.video) {
      this.init();
    }
  }
  
  init() {
    this.element.addEventListener('mouseenter', () => {
      clearTimeout(this.pauseTimeout);
      this.playTimeout = setTimeout(() => {
        this.video.play().catch(err => {
          console.warn('Video play failed:', err);
        });
      }, this.playDelay);
    });
    
    this.element.addEventListener('mouseleave', () => {
      clearTimeout(this.playTimeout);
      this.pauseTimeout = setTimeout(() => {
        this.video.pause();
        this.video.currentTime = 0;
      }, this.pauseDelay);
    });
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// 13. FADE IN ON SCROLL (Generic fade-in animation)
// LOCATION: story.html (.animate), studio.html (.item)
// ELEMENTS: Any element with fade-in behavior
// ═══════════════════════════════════════════════════════════════════════════

class ExoFadeIn {
  constructor(element, options = {}) {
    this.element = element;
    this.threshold = options.threshold || 0.2;
    this.delay = options.delay || 0;
    this.duration = options.duration || 0.8;
    this.y = options.y || 50;
    
    this.init();
  }
  
  init() {
    if (typeof ScrollTrigger === 'undefined') {
      // Fallback to simple RAF check
      this.setupRAF();
      return;
    }
    
    gsap.from(this.element, {
      y: this.y,
      autoAlpha: 0,
      duration: this.duration,
      delay: this.delay,
      ease: 'exoImage',
      scrollTrigger: {
        trigger: this.element,
        start: `top ${100 - this.threshold * 100}%`,
        once: true
      }
    });
  }
  
  setupRAF() {
    gsap.set(this.element, { autoAlpha: 0, y: this.y });
    
    const checkVisibility = () => {
      if (ExoUtils.inView(this.element, window.innerHeight * this.threshold)) {
        gsap.to(this.element, {
          y: 0,
          autoAlpha: 1,
          duration: this.duration,
          delay: this.delay,
          ease: 'exoImage'
        });
      } else {
        requestAnimationFrame(checkVisibility);
      }
    };
    
    requestAnimationFrame(checkVisibility);
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// 14. VIEWPORT HEIGHT FIX (CSS custom property for mobile)
// LOCATION: ALL PAGES
// ═══════════════════════════════════════════════════════════════════════════

function ExoViewportFix() {
  const setVH = () => {
    const vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
  };
  
  setVH();
  window.addEventListener('resize', setVH);
  window.addEventListener('orientationchange', setVH);
}

// ═══════════════════════════════════════════════════════════════════════════
// 15. LINK BUTTON ANIMATION (Circular button with arrow)
// LOCATION: ALL PAGES
// ELEMENTS: .link (with .circle, .circle-fill, .circle-outline, .circle-icon)
// ═══════════════════════════════════════════════════════════════════════════

class ExoLinkButton {
  constructor(element, options = {}) {
    this.element = element;
    this.circleFill = element.querySelector('.circle-fill');
    this.circleIcon = element.querySelector('.circle-icon');
    this.duration = options.duration || 0.4;
    
    if (this.circleFill || this.circleIcon) {
      this.init();
    }
  }
  
  init() {
    this.element.addEventListener('mouseenter', () => {
      if (this.circleFill) {
        gsap.to(this.circleFill, {
          scale: 1,
          duration: this.duration,
          ease: 'exoImage'
        });
      }
      
      if (this.circleIcon) {
        gsap.to(this.circleIcon, {
          x: 5,
          duration: this.duration,
          ease: 'exoImage'
        });
      }
    });
    
    this.element.addEventListener('mouseleave', () => {
      if (this.circleFill) {
        gsap.to(this.circleFill, {
          scale: 0,
          duration: this.duration,
          ease: 'exoImage'
        });
      }
      
      if (this.circleIcon) {
        gsap.to(this.circleIcon, {
          x: 0,
          duration: this.duration,
          ease: 'exoImage'
        });
      }
    });
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// ❌ NOT IMPLEMENTED - WORK.HTML PAGE (Not in current scope)
// ═══════════════════════════════════════════════════════════════════════════

/*
 * The following animations are present in the original Exo Ape site but are
 * NOT implemented here because they belong to work.html, which is not in your
 * current 4-page scope (index, studio, story, columbia-pictures).
 *
 * 16. PROJECT CAROUSEL (3D Card Stacking)
 * LOCATION: work.html
 * ELEMENTS: .work-carousel, .work-card
 * DESCRIPTION: Mouse wheel-driven horizontal carousel with stacked card effect
 * SOURCE: Custom component with 3D transforms and perspective
 *
 * 17. DRAG TO NAVIGATE (Touch/Mouse Drag)
 * LOCATION: work.html carousel
 * ELEMENTS: .work-carousel
 * DESCRIPTION: Drag interaction for project navigation
 * SOURCE: Custom drag handler with momentum scrolling
 *
 * 18. PROJECT FILTER (Category Filtering)
 * LOCATION: work.html
 * ELEMENTS: .filter-nav, .filter-button
 * DESCRIPTION: Filter projects by category with animated transitions
 * SOURCE: Custom filtering with GSAP timeline animations
 *
 * If you need these animations, they can be added to a separate
 * work-page-specific JS file.
 */

// ═══════════════════════════════════════════════════════════════════════════
// ❌ NOT IMPLEMENTED - NEWS/CONTACT PAGES (Not in current scope)
// ═══════════════════════════════════════════════════════════════════════════

/*
 * 19. FORM VALIDATION & ANIMATION (Contact Form)
 * LOCATION: contact.html
 * ELEMENTS: .contact-form, .form-input
 * DESCRIPTION: Animated form inputs with floating labels and validation
 * SOURCE: Custom form handler with GSAP animations
 *
 * 20. NEWS GRID ANIMATION (Staggered Grid)
 * LOCATION: news.html
 * ELEMENTS: .news-grid, .news-item
 * DESCRIPTION: Masonry-style grid with staggered reveal
 * SOURCE: Custom grid layout with ScrollTrigger batch
 *
 * 21. ARTICLE PAGE PROGRESS BAR
 * LOCATION: news/[slug].html
 * ELEMENTS: .reading-progress
 * DESCRIPTION: Progress bar that fills as you read article
 * SOURCE: Simple scroll progress calculation
 */

// ═══════════════════════════════════════════════════════════════════════════
// 16. AUTO-INITIALIZATION & MAIN API
// ═══════════════════════════════════════════════════════════════════════════

const Exo = {
  // Core instances
  smoothScroll: null,
  pageTransition: null,
  navigation: null,
  
  // Collections
  titleSplits: [],
  marquees: [],
  imageBlooms: [],
  parallaxElements: [],
  canvasVideos: [],
  videoHovers: [],
  fadeIns: [],
  linkButtons: [],
  scrollTos: [],
  
  // Initialize all animations
  init(options = {}) {
    console.log('🎬 Initializing Exo Ape Animations...');
    
    // Register GSAP plugins
    if (typeof gsap !== 'undefined') {
      if (typeof ScrollTrigger !== 'undefined') {
        gsap.registerPlugin(ScrollTrigger);
        console.log('✅ ScrollTrigger registered');
      }
      if (typeof CustomEase !== 'undefined') {
        gsap.registerPlugin(CustomEase);
        console.log('✅ CustomEase registered');
      }
    } else {
      console.error('❌ GSAP not found. Please include GSAP before Exo Ape.');
      return;
    }
    
    // Set viewport height fix
    ExoViewportFix();
    console.log('✅ Viewport height fix applied');
    
    // Initialize smooth scroll
    if (!options.disableSmoothScroll && !ExoUtils.isMobile()) {
      this.smoothScroll = new ExoSmoothScroll(options.smoothScroll || {});
      console.log('✅ Smooth scroll initialized');
    }
    
    // Initialize page transitions
    this.pageTransition = new ExoPageTransition();
    console.log('✅ Page transitions ready');
    
    // Initialize navigation
    this.navigation = new ExoNavigation(options.navigation || {});
    console.log('✅ Navigation initialized');
    
    // Auto-init elements with data attributes
    this.autoInit();
    
    console.log('✨ Exo Ape Animations Ready!');
  },
  
  autoInit() {
    // Title split animations
    document.querySelectorAll('[data-exo-title]').forEach(el => {
      const titleSplit = new ExoTitleSplit(el);
      this.titleSplits.push(titleSplit);
    });
    console.log(`✅ ${this.titleSplits.length} title animations initialized`);
    
    // Marquee animations
    document.querySelectorAll('[data-exo-marquee]').forEach(el => {
      const speed = parseFloat(el.dataset.exoMarquee) || 1;
      const marquee = new ExoMarquee(el, { speed });
      this.marquees.push(marquee);
    });
    console.log(`✅ ${this.marquees.length} marquee animations initialized`);
    
    // Image bloom effects
    document.querySelectorAll('[data-exo-bloom]').forEach(el => {
      const trigger = el.dataset.exoBloom || 'scroll';
      const bloom = new ExoImageBloom(el, { trigger });
      this.imageBlooms.push(bloom);
    });
    console.log(`✅ ${this.imageBlooms.length} image bloom effects initialized`);
    
    // Parallax elements
    document.querySelectorAll('[data-exo-parallax]').forEach(el => {
      const speed = parseFloat(el.dataset.exoParallax) || 0.5;
      const parallax = new ExoParallax(el, { speed });
      this.parallaxElements.push(parallax);
    });
    console.log(`✅ ${this.parallaxElements.length} parallax elements initialized`);
    
    // Scroll indicators
    document.querySelectorAll('[data-exo-scroll-to]').forEach(el => {
      const scrollTo = new ExoScrollTo(el);
      this.scrollTos.push(scrollTo);
    });
    console.log(`✅ ${this.scrollTos.length} scroll indicators initialized`);
    
    // Canvas videos
    document.querySelectorAll('[data-exo-canvas]').forEach(el => {
      const frameCount = parseInt(el.dataset.exoCanvas) || 150;
      const folder = el.dataset.exoFolder || '/frames';
      const canvas = new ExoCanvasVideo(el, { frameCount, folder });
      this.canvasVideos.push(canvas);
    });
    console.log(`✅ ${this.canvasVideos.length} canvas videos initialized`);
    
    // Video hover effects
    document.querySelectorAll('.project, .block').forEach(el => {
      if (el.querySelector('video')) {
        const videoHover = new ExoVideoHover(el);
        this.videoHovers.push(videoHover);
      }
    });
    console.log(`✅ ${this.videoHovers.length} video hover effects initialized`);
    
    // Fade-in elements
    document.querySelectorAll('[data-exo-fade-in], .animate').forEach(el => {
      const fadeIn = new ExoFadeIn(el);
      this.fadeIns.push(fadeIn);
    });
    console.log(`✅ ${this.fadeIns.length} fade-in animations initialized`);
    
    // Link buttons
    document.querySelectorAll('.link').forEach(el => {
      const linkButton = new ExoLinkButton(el);
      this.linkButtons.push(linkButton);
    });
    console.log(`✅ ${this.linkButtons.length} link buttons initialized`);
  },
  
  // Manual initialization methods
  createTitleSplit(element, options) {
    const titleSplit = new ExoTitleSplit(element, options);
    this.titleSplits.push(titleSplit);
    return titleSplit;
  },
  
  createMarquee(element, options) {
    const marquee = new ExoMarquee(element, options);
    this.marquees.push(marquee);
    return marquee;
  },
  
  createImageBloom(element, options) {
    const bloom = new ExoImageBloom(element, options);
    this.imageBlooms.push(bloom);
    return bloom;
  },
  
  createParallax(element, options) {
    const parallax = new ExoParallax(element, options);
    this.parallaxElements.push(parallax);
    return parallax;
  },
  
  createCanvasVideo(element, options) {
    const canvas = new ExoCanvasVideo(element, options);
    this.canvasVideos.push(canvas);
    return canvas;
  },
  
  createFadeIn(element, options) {
    const fadeIn = new ExoFadeIn(element, options);
    this.fadeIns.push(fadeIn);
    return fadeIn;
  },
  
  // Utility methods
  scrollTo(targetY, duration) {
    if (this.smoothScroll) {
      this.smoothScroll.scrollTo(targetY, duration);
    } else {
      window.scrollTo({
        top: targetY,
        behavior: 'smooth'
      });
    }
  },
  
  refresh() {
    if (typeof ScrollTrigger !== 'undefined') {
      ScrollTrigger.refresh();
    }
  },
  
  destroy() {
    if (this.smoothScroll) {
      this.smoothScroll.destroy();
    }
    
    this.titleSplits = [];
    this.marquees = [];
    this.imageBlooms = [];
    this.parallaxElements = [];
    this.canvasVideos = [];
    this.videoHovers = [];
    this.fadeIns = [];
    this.linkButtons = [];
    this.scrollTos = [];
    
    if (typeof ScrollTrigger !== 'undefined') {
      ScrollTrigger.getAll().forEach(st => st.kill());
    }
    
    gsap.globalTimeline.clear();
  }
};

// Auto-initialize on DOMContentLoaded
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    Exo.init();
  });
} else {
  Exo.init();
}

// Export for module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = Exo;
}

/**
 * ═══════════════════════════════════════════════════════════════════════════
 * USAGE EXAMPLES
 * ═══════════════════════════════════════════════════════════════════════════
 * 
 * Basic Usage (Auto-initialization):
 * <script src="gsap.min.js"></script>
 * <script src="ScrollTrigger.min.js"></script>
 * <script src="CustomEase.min.js"></script>
 * <script src="exoape-master.js"></script>
 * 
 * Custom Initialization:
 * <script>
 *   // Wait for page load
 *   document.addEventListener('DOMContentLoaded', () => {
 *     Exo.init({
 *       disableSmoothScroll: false,
 *       smoothScroll: {
 *         ease: 0.1
 *       },
 *       navigation: {
 *         hideOnScroll: false,
 *         threshold: 100
 *       }
 *     });
 *   });
 * </script>
 * 
 * Manual Element Initialization:
 * <script>
 *   const myTitle = document.querySelector('.my-title');
 *   Exo.createTitleSplit(myTitle, { threshold: 200 });
 * </script>
 * 
 * Data Attribute Usage:
 * <h1 class="title" data-exo-title>Animated Title</h1>
 * <div class="marquee" data-exo-marquee="1.5">Content</div>
 * <div class="image" data-exo-bloom="hover">Image</div>
 * <div class="element" data-exo-parallax="0.7">Parallax</div>
 * <canvas data-exo-canvas="150" data-exo-folder="/frames"></canvas>
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 */
